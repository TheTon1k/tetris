const create = (elem) => {
  return document.createElement(elem);
};
function getGamePage (){
const wrapper = document.getElementById('wrapper')
wrapper.innerHTML=''
const canvas = create('canvas')
wrapper.appendChild(canvas)
const canvas = document.getElementById("tetris");
const context = canvas.getContext("2d");
const divScore = document.getElementById("score");

const nextFigureCanvas = document.getElementById("nextFigure");
const contextNextFigure = nextFigureCanvas.getContext("2d");

contextNextFigure.scale(100, 100);

//размер поля 600x720
canvas.width = 600;
canvas.height = 720;

// размеры блока со следующей фигурой
nextFigureCanvas.width = 126;
nextFigureCanvas.height = 126;

//размер одного блока фигуры
const blockSize = 30;
//количество строк и столбцов
let rowsSize = canvas.height / blockSize;
let colsSize = canvas.width / blockSize;

//счет
let score = 0;
//фигуры
const figures = {
  L: [
    [0, 0, 1],
    [1, 1, 1],
    [0, 0, 0],
  ],
  J: [
    [1, 0, 0],
    [1, 1, 1],
    [0, 0, 0],
  ],
  Z: [
    [1, 1, 0],
    [0, 1, 1],
    [0, 0, 0],
  ],
  S: [
    [0, 1, 1],
    [1, 1, 0],
    [0, 0, 0],
  ],
  I: [
    [0, 0, 0, 0],
    [1, 1, 1, 1],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
  ],
  T: [
    [0, 1, 0],
    [1, 1, 1],
    [0, 0, 0],
  ],

  O: [
    [1, 1],
    [1, 1],
  ],
};

const figuresColors = {
  L: "#78DBE2",
  J: "#F19CBB",
  S: "#FFAA64",
  Z: "#FCE883",
  T: "#D0F0C0",
  I: "#FFF8E7",
  O: "#1DACD6",
};
//счетчик кадров для сдвига фигуры
let counter = 0;
//каждый 30й кадр сдвигаем фигуру вниз
let maxCounter = 30;
//каждые 30 секунд увеличиваем скорость падения фигуры(max-counter) на 1
let speedUp = 30;
//каждые 10 собранных рядов увеличиваем скорость падения фигуры(max-counter) на 1
let clearedRows = 0;

//массив с фигурами
let figuresArray = [];
//игровое поле
let arena = [];
//начинаем с -1 чтобы изначально появлялись фигуры не полностью
for (let row = -1; row < rowsSize; row++) {
  arena[row] = new Array(colsSize).fill(0);
}

// текущая фигура
let currentFigure = getNextFigure();

let nextFigure = null;

// флаг конца игры, на старте — неактивный
let gameOver = false;

let animation = null;

// Функция возвращает случайное число в заданном диапазоне
function getRandomFigure(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// создаём последовательность фигур, которая появится в игре
function generateSequence() {
  const sequence = ["L", "J", "Z", "S", "I", "T", "O"];

  // выбираем рандомную фигуру
  while (sequence.length) {
    const randomFigure = getRandomFigure(0, sequence.length - 1);
    const name = sequence.splice(randomFigure, 1)[0];
    // помещаем выбранную фигуру в игровой массив с последовательностями
    figuresArray.push(name);
  }
}

// получаем следующую фигуру
function getNextFigure() {
  // если следующей нет — генерируем
  if (figuresArray.length === 0) {
    generateSequence();
  }
  // берём последнюю фигуру из массива
  const name = figuresArray.pop();
  // сразу создаём матрицу, с которой мы отрисуем фигуру
  const matrix = figures[name];
  // I и O стартуют с середины, остальные — чуть левее

  const col = arena[0].length / 2 - Math.ceil(matrix[0].length / 2);
  const row = -1;
  // вот что возвращает функция
  return {
    name, // имя фигуры
    matrix, // матрица фигуры
    row, // текущая строка
    col, // текущий столбец
  };
}

// поворачиваем матрицу на 90 градусов
function rotateFigure(matrix) {
  const N = matrix.length - 1;
  const result = matrix.map((row, i) => row.map((val, j) => matrix[N - j][i]));
  // на входе матрица, и на выходе тоже отдаём матрицу
  return result;
}

// проверяем может ли фигура быть в этом месте поля или она вылезет за его границы
function isValidMove(matrix, cellRow, cellCol) {
  // проверяем все строки и столбцы
  for (let row = 0; row < matrix.length; row++) {
    for (let col = 0; col < matrix[row].length; col++) {
      if (
        matrix[row][col] &&
        // если выходит за границы поля…
        (cellCol + col < 0 ||
          cellCol + col >= arena[0].length ||
          cellRow + row >= arena.length ||
          // …или пересекается с другими фигурами
          arena[cellRow + row][cellCol + col])
      ) {
        // то возвращаем, что нет, так не пойдёт
        return false;
      }
    }
  }
  // а если мы дошли до этого момента и не закончили раньше — то всё в порядке
  return true;
}

// когда фигура окончательна встала на своё место
function placeFigure() {
  // обрабатываем все строки и столбцы в игровом поле
  for (let row = 0; row < currentFigure.matrix.length; row++) {
    for (let col = 0; col < currentFigure.matrix[row].length; col++) {
      if (currentFigure.matrix[row][col]) {
        // если край фигуры после установки вылезает за границы поля, то игра закончилась
        if (currentFigure.row + row < 0) {
          return showGameOver();
        }
        // если всё в порядке, то записываем в массив игрового поля нашу фигуру
        arena[currentFigure.row + row][currentFigure.col + col] =
          currentFigure.name;
      }
    }
  }
  // проверяем, чтобы заполненные ряды очистились снизу вверх
  for (let row = arena.length - 1; row >= 0; ) {
    // если ряд заполнен
    if (arena[row].every((cell) => !!cell)) {
      // очищаем его и опускаем всё вниз на одну клетку
      for (let r = row; r >= 0; r--) {
        for (let c = 0; c < arena[r].length; c++) {
          arena[r][c] = arena[r - 1][c];
        }
      }
      score += 200;
      clearedRows++;
    } else {
      // переходим к следующему ряду
      row--;
    }
  }
  //
  // получаем следующую фигуру
  currentFigure = getNextFigure();
}

function showGameOver() {
  cancelAnimationFrame(animation);
  gameOver = true;
  context.fillStyle = "#000000";
  context.globalAlpha = 0.75;
  context.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);
  context.globalAlpha = 1;
  context.fillStyle = "white";
  context.font = "36px";
  context.textAlign = "center";
  context.textBaseline = "middle";
  context.fillText("GAME OVER!", canvas.width / 2, canvas.height / 2);
}

document.addEventListener("keydown", (e) => {
  if (gameOver) return;

  switch (e.keyCode) {
    case 37:
      if (
        isValidMove(
          currentFigure.matrix,
          currentFigure.row,
          currentFigure.col - 1
        )
      ) {
        currentFigure.col -= 1;
        console.log(currentFigure.col);
      }
      break;
    case 39:
      if (
        isValidMove(
          currentFigure.matrix,
          currentFigure.row,
          currentFigure.col + 1
        )
      ) {
        currentFigure.col += 1;
      }
      break;
    case 40:
      if (
        !isValidMove(
          currentFigure.matrix,
          currentFigure.row + 1,
          currentFigure.col
        )
      ) {
        placeFigure();
        return;
      }
      score += 1;
      currentFigure.row += 1;
      break;
    case 38:
      const newMatrix = rotateFigure(currentFigure.matrix);
      if (isValidMove(newMatrix, currentFigure.row, currentFigure.col)) {
        currentFigure.matrix = newMatrix;
      }
      break;
  }
});

function updateScore() {
  divScore.innerText = score;
}

updateScore();

function update(time = 0) {
  updateScore();
  animation = requestAnimationFrame(update);
  context.fillStyle = "black";
  context.fillRect(0, 0, canvas.width, canvas.height);

  if (currentFigure) {
    //каждые maxCounter кадров сдвигаем фигуру
    if (counter++ >= maxCounter) {
      currentFigure.row++;
      counter = 0;
    }
    if (time / 1000 >= speedUp) {
      console.log(time);
      console.log(speedUp);
      maxCounter--;
      speedUp += 30;
    }
    //каждые 10 собранных рядов увеличиваем скорость падения
    if (clearedRows >= 10) {
      maxCounter -= 1;
      clearedRows = 0;
    }

    if (
      !isValidMove(currentFigure.matrix, currentFigure.row, currentFigure.col)
    ) {
      currentFigure.row--;
      placeFigure();
    }
    context.fillStyle = figuresColors[currentFigure.name];

    //рисуем фигуру
    for (let row = 0; row < currentFigure.matrix.length; row++) {
      for (let col = 0; col < currentFigure.matrix[row].length; col++) {
        if (currentFigure.matrix[row][col]) {
          context.fillRect(
            (currentFigure.col + col) * blockSize,
            (currentFigure.row + row) * blockSize,
            blockSize - 2,
            blockSize - 2
          );
        }
      }
    }
  }
  //рисуем следующую фигуру
  if (figuresArray.length > 0) {
    if (nextFigure !== figuresArray[figuresArray.length - 1]) {
      contextNextFigure.fillStyle = "black";
      contextNextFigure.fillRect(
        0,
        0,
        nextFigureCanvas.width,
        nextFigureCanvas.height
      );
      nextFigure = figuresArray[figuresArray.length - 1];
      let matrix = figures[nextFigure];
      contextNextFigure.fillStyle = figuresColors[nextFigure];
      for (let row = 0; row < matrix.length; row++) {
        for (let col = 0; col < matrix[row].length; col++) {
          if (matrix[row][col]) {
            contextNextFigure.fillRect(
              col * blockSize +
                (nextFigure === "O"
                  ? blockSize
                  : nextFigure === "I"
                  ? blockSize / 6
                  : blockSize / 2),
              nextFigure === "I"
                ? nextFigureCanvas.height / 3
                : nextFigureCanvas.height / 4 + row * blockSize,
              blockSize - 2,
              blockSize - 2
            );
          }
        }
      }
    }
  }
  //отрисовываем игровое поле исходя из заполненных ячеек
  for (let row = 0; row < rowsSize; row++) {
    for (let col = 0; col < colsSize; col++) {
      if (arena[row][col]) {
        const name = arena[row][col];
        context.fillStyle = figuresColors[name];

        //чтобы была клетка делаем заливку на 1 пиксель меньше размера блока
        context.fillRect(
          col * blockSize,
          row * blockSize,
          blockSize - 2,
          blockSize - 2
        );
      }
    }
  }
}
}
// animation = requestAnimationFrame(update);
